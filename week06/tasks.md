# Задачи за седмица 6

### Зад. 1 - **прехвърлена oт миналата седмица**

Да се напише фукнция `bool contains(int array[], int size, int elem)`, която проверява дали `elem` е елемент на `array`.

### Зад. 2 - **прехвърлена от миналата седмица**

Да се напише фукнция `void replace(int array[], int size, int find, int search)`, която заменя всички срещания на `find` в `array` с `replace`.

### Зад. 3

Да се напише булева функция: 

* която проверява дали даден символен низ започва с друг символен низ
* която проверява дали даден символен низ завършва с друг символен низ

### Зад. 4

Да се напише булева функция, която проверява дали елементите на един масив образуват аритметична прогресия.

### Зад. 5

Да се напише програма, която кара потребителя да въведе коефициентите на полином и число х и след това да изкарва на екрана стойността на полинома в х.

Пример:

```
<< Коефициенти:
>> 1 2 3  // това е полиномът 1 + 2 * x + 3 * (x^2) 
<< x:
>> 2
<< Стойността е : 17
```

### Зад. 6

Да се напише функция `void substring(char source[], int beginIndex, int endIndex, char target[])`, която копира всички елементи на `source` между позиция `beginIndex` и `endIndex` в `target`.

### Зад. 7

Нека имаме масив от N точки в равнината: p[0], p[1].... p[N - 1]. Да се напише функция която намира дължината на пътя от p[0] до p[N - 1], като можем да се придвижим от p[i] до p[i + 1] само по права линия.

### Зад. 8

Да се напише булева функция, която приема два масива и връща true, ако всички елементи на първия масив са по-малки или равни от всички елементи на втория масив и false в противен случай.

### Зад. 9

Да се напише функция `void trim(char original[], char trimmed[])`, която копира `original` в `trimmed` без всички space-ове в началото и края на низа.

Пример:
```c++
char original[50] = "    abc    ";
char trimmed[50];
trim(original, trimmed);
std::cout << trimmed; // "abc"

```

### Зад. 10

Нека имаме масив от N точки в равнината: p[0], p[1].... p[N - 1]. Да се напише функция която намира дължината на пътя от p[0] до p[N - 1], като можем да се придвижим от p[i] до p[i + 1] само по права линия.

### Зад. 11 - **прехвърлена от миналата седмица**

Да се напише програма, която кара потребителя да въведе масив от цели числа и в нов масив на i-тата позиция да се записва броя на числата, които са по-малки от i-тия елемнт на първия масив и стоят на позция по-голяма от него(т.е. са вдясно от него).

Пример:

```
<< input 	
>> array1[]={1, 2, 3, 4, 2, 3}
<< output
<< array2[]={0, 0, 1, 2, 0, 0}
```


### Зад. 12

Цикъл в масив(arr) ще наричаме поредица от индекси i1, i2, i3, ..., in, за която arr[i1] = i2, arr[i2] = i3, ..., arr[in] = i1. Цикличен масив ще наричаме този, за който съществува един единствен цикъл, обхващащ всичките му елементи
Да се напиша булева функция, която проверява дали един масив е цикличен. 

Пример:
```c++
int arr[] = {2, 0, 1}; // arr е цикличен, защото arr[0] = 2, arr[2] = 1, arr[1] = 0
int arr[] = {2, 0, 1, 3}; // arr не е цикличен, защото има два цикъла: arr[0] = 2, arr[2] = 1, arr[1] = 0 и arr[3] = 3
int arr[] = {14, 0, 3}; // arr не е цикличен, защото arr[0] надхвърля размера на масива

int arr[] = {2, 2, 2}; // arr не е цикличен
```

Бонус: Да се напише функция, която връща броя на всички цикли в един масив. (приемете, че всеки елемент на масива е в диапазона [0, n - 1], където n е размерът на масива, и всеки елемент се среща само по веднъж)
