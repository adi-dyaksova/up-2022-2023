#include <iostream>

/*
    Цикъл в масив(arr) ще наричаме поредица от индекси i1, i2, i3, ..., in, за която arr[i1] = i2, arr[i2] = i3, ..., arr[in] = i1.
    Цикличен масив ще наричаме този, за който съществува един единствен цикъл, обхващащ всичките му елементи.
    Да се напиша булева функция, която проверява дали един масив е цикличен.
*/

bool isCyclic(int arr[], int size)
{
    // Често срещана техника, когато работим с масиви и ги обхождаме. Масивът visited, ще пази информация дали сме "посетили" даден елемент.
    // Ще изградим visited масива по следния начин: visited[i] == true <=> елементът arr[i] е бил обходен
    bool visited[256]; // Поради лимитация в текущите ни знания, трябва да инциализираме масива със статичен размер. Програмата ни няма да работи коректно за масиви с размер > 256.

    // В началото никой елемент не е бил посетен
    for (int i = 0; i < size; i++)
        visited[i] = false;

    // Започваме да скачаме по индексите
    int currentIndex = 0;
    // Ако изскочим от границите на масива или стигнем до елемент, който вече е бил посетен(т.е. сме намерили цикъл), приключваме.
    while (currentIndex < size && !visited[currentIndex])
    {
        // Отбелязваме текущия елемент като посетен
        visited[currentIndex] = true;

        // Скачаме на следващия индекс
        currentIndex = arr[currentIndex];
    }

    // Проверяваме дали сме посетили всички елементи. Ако открием непосетен елемент, значи цикълът не обхваща всички елементи.
    for (int i = 0; i < size; i++)
    {
        if (!visited[i])
            return false;
    }

    return true;
}

int main()
{
    int arr1[3] = {2, 0, 1};
    int arr2[4] = {2, 0, 1, 3};
    int arr3[3] = {14, 0, 3};
    int arr4[3] = {2, 2, 2};

    std::cout << isCyclic(arr1, 3) << std::endl;
    std::cout << isCyclic(arr2, 4) << std::endl;
    std::cout << isCyclic(arr3, 3) << std::endl;
    std::cout << isCyclic(arr3, 3) << std::endl;

    return 0;
}