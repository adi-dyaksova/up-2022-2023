#include <iostream>

/*
    Нека е дадена матрица NxМ (N,М<=100), която е съставена само от 0 и 1 и за която има един единствен път от клетката с координати (0, 0)
    до клетка с координати (N - 1, M - 1) съставен само от 1ици(движението от една клетка в друга става по диагонал, вертикал и хоризонтал).
    Напишете програма, която намира този път и отпечатва координатите му на екрана.
*/

// Помощна функция, която ще ни казва дали можем да продължим с клетка (i, j)
bool nextMove(bool matrix[100][100], int rows, int cols, int i, int j)
{
    if (i < 0 || i >= rows || j < 0 || j >= cols)
        return false;
    return matrix[i][j];
}

void printPath(bool matrix[100][100], int rows, int cols)
{
    // Почваме от първата клетка.
    int i = 0;
    int j = 0;

    // Докато не стигнем последната
    while (i != rows - 1 || j != cols - 1)
    {
        // Отпечатваме текущото състояние
        std::cout << "(" << i << ", " << j << ")"
                  << " -> ";

        // Пробваме да тръгнем надясно
        if (nextMove(matrix, rows, cols, i + 1, j))
        {
            i += 1;
        }
        // Пробваме да тръгнем надолу
        else if (nextMove(matrix, rows, cols, i, j + 1))
        {
            j += 1;
        }
        // Пробваме да тръгнем по диагонал
        else if (nextMove(matrix, rows, cols, i + 1, j + 1))
        {
            i += 1;
            j += 1;
        }
        // Ако нито едно от предишните не се получи, значи сме стигнали задъдена улица
        else
        {
            std::cout << "oops, dead end!" << std::endl;
            return;
        }
    }

    // Отпечатваме финалното състояние
    std::cout << "(" << i << ", " << j << ")" << std::endl;
}

int main()
{
    bool labyrinth[100][100] = {{1, 0, 0, 1},
                                {0, 1, 0, 0},
                                {0, 1, 0, 0},
                                {0, 1, 1, 1}};

    printPath(labyrinth, 4, 4);

    return 0;
}