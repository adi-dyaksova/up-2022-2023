#include <iostream>

int main()
{
    int a = 5;
    // референция към а
    int &b = a;

    // референцията ползваме по абослютно същия начин като нормална променлива
    int c = b + 3;

    // промяна във референция се отразява и в оригиналната променлива
    b = 10;
    std::cout << "а = " << a << std::endl; // 10

    int d = 5;
    // Указател, който приема адреса на променливата d. Казваме, че указателят сочи към d
    int *e = &d;

    // с опертатор * вземаме стойността, към която сочи указателя
    std::cout << "*e = " << *e << std::endl; // 5

    // можем да презаписваме стойността, към която сочи указаеля
    *e = 3;

    std::cout << "d = " << d << std::endl; // 3

    int f = 10;
    // указателят, може да бъде пренасочван
    e = &f;

    std::cout << "*e = " << *e << std::endl; // 10

    // този път d остава непроменено, защото указателят вече не сочи към него
    *e = 4;
    std::cout << "d = " << d << std::endl; // 3


    // arr е указател към първия елемент на масива и
    // съответно можем да го присвояваме на променлива, която е указател
    int arr[] = {1, 2, 3};
    int *p = arr;
    
    // Обхождане на масива по стандартния начин
    for (int i = 0; i < 3; i++)
    {
        std::cout << "arr[" << i << "] = " << arr[i] << std::endl;
    }

    // Обхождане на масива през указател
    for (int i = 0; i < 3; i++)
    {   
        // (p + i) - стандартна операция с указател, при която отиваме на адрес i позиции, след тази към която сочи p
         std::cout << "*(p + " << i << ") = " << *(p + i) << std::endl;
    }

    // Обхождане на масива през указател отзад напред
    int *r = arr + 2;
    for (int i = 0; i < 3; i++)
    {   
        // можем да местим указателя и назад
         std::cout << "*(r - " << i << ") = " << *(r - i) << std::endl;
    }

    return 0;
}